### Rendering properties  ###

(include color.grammar)

(rule $ColorPhrase ($ColorValue) (IdentityFn))
(rule $ColorPhrase (color $ColorValue) (IdentityFn))
(rule $ColorPhrase ($ColorValue color) (IdentityFn))
(rule $ColorPhrase (to $ColorPhrase) (IdentityFn))

(rule $PropertyValue ($ColorChange) (IdentityFn))
(rule $PropertyValue ($ColorPhrase) (IdentityFn))
(rule $PropertyValue ($ValueChange) (IdentityFn))
(rule $PropertyValue ((to optional) $Number) (IdentityFn))

# supported rendering properties
(rule $ColorProperty (color) (ConstantFn (string "color")))
(rule $ColorProperty (border) (ConstantFn (string "border")))
(rule $ValueProperty (opacity) (ConstantFn (string "opacity")))
(rule $ValueProperty (size) (ConstantFn (string "size")))
(rule $ValueProperty (width) (ConstantFn (string "width")))

(rule $Property ($ColorProperty) (IdentityFn))
(rule $Property ($ValueProperty) (IdentityFn))

# encoding keywords
(def @encode (string "encode"))
(rule $Encode ($TOKEN) (FilterTokenFn lemma encode map))

# width set 5
(rule $PropertySetter ($Assign) (ConstantFn (lambda y (lambda x (call + (var x) (call + (string " ") (var y)))))))
(rule $PropertyPartial ($PropertySetter $PropertyValue) (JoinFn forward))
(rule $AssignProperty ($Property $PropertyPartial) (JoinFn backward))
# set width 5
(rule $AssignProperty (($Assign optional) $Property $PropertyValue) (ConcatFn " "))
# set 5 width
(rule $PropertyPartial3 ($PropertySetter $PropertyValue) (JoinFn forward))
(rule $AssignProperty ($PropertyPartial3 $Property) (JoinFn forward))

# increase width
(rule $AssignProperty ($ValueChange $Property) (ConcatFn reverse " "))
(rule $AssignProperty ($ValueChange $Property) (ConcatFn reverse " "))

# width increase
(rule $AssignProperty ($Property $ValueChange) (ConcatFn " "))

# set width 5 and opacity 1
(rule $AssignProperty ($AssignProperty ($Conj optional) $AssignProperty) (ConcatFn " "))

# color from red to green (not yet differentiate different scales here)
(rule $ScaleValue ($ColorProperty from ($PHRASE optional)) (ConstantFn @colorscale_redgreen))

(rule $ScaleValue ($PrepBy $ScaleValue) (SelectFn 1))
(rule $ScaleValue ($NumericalScale) (IdentityFn))

# map mpg to size from 5 to 6
# Strangely, if the phrase is in the form "5 to 6", the CoreNLP parser in sempre fails to parse it with grammar
# "$Number to $Number". We suspect it is because of the implementation of the sempre CoreNLP class. Further investigation pending.
# For the moment a get-around is to use $NumberToken. This will not interpret sth like "one billion" of course.
(rule $ValueRange ($NumberToken (to optional) $NumberToken) (ConcatFn " "))
(rule $ValueRange ($Number ($Conj optional) $Number) (ConcatFn " "))
(rule $ValueRange (from $ValueRange) (IdentityFn))

# map mpg to 5 and 6 size
(rule $NumericalScale (($PrepBy optional) $ValueRange $ValueProperty) (ConcatFn reverse " "))
(rule $NumericalScale (($PrepBy optional) $ValueProperty $ValueRange) (ConcatFn " "))

(rule $AssignProperty (($Encode optional) $Dim $NumericalScale) (JoinFn backward))

# (color) encode mpg
(def @default_color_encode (string "color redGreen"))
(rule $EncodeDefault ($Encode) (ConstantFn @default_color_encode))
(rule $EncodeDefault (color $Encode) (ConstantFn @default_color_encode))
(rule $AssignProperty ($EncodeDefault $Dim) (ConcatFn " "))

# encode mpg by red green color scale
(rule $AssignProperty (($Encode optional) $Dim ($PrepBy optional) $ScaleValue) (ConcatFn reverse " "))


### Application ###
(rule $Command ($AssignProperty) (IdentityFn))
