(include pos.grammar)
(include stop.grammar)
(include column.grammar)

### Auxiliary tokens ###

# Date
(rule $Date ($PHRASE) (DateFn))

# Number
(rule $NumberPhrase ($PHRASE) (FilterPosTagFn token CD))
(rule $Number ($NumberPhrase) (NumberFn))

(rule $RangeValue ($Number) (IdentityFn))
(rule $RangeValue ($Date) (IdentityFn))

# 5 to 6, from 5 to 6, etc
(rule $NumericalRange (($Prep optional) $RangeValue ($Prep optional) $RangeValue) (ConcatFn ":"))
# Strangely, sempre NumberFn fails to parse "from 5 to 6".
# It may be because of the implementation of the sempre CoreNLP class. 
# For the moment a get-around is to use $NumberPhrase,
# which however does not interpret string phrase "one billion".
(rule $NumericalRange (($Prep optional) $NumberPhrase ($Prep optional) $NumberPhrase) (ConcatFn ":"))


(def @percent (string "%"))
(rule $PercentToken_ ($TOKEN) (FilterTokenFn lemma % percent percentage))
(rule $PercentToken ($PercentToken_) (ConstantFn @percent))
# This will return "5 percent" or "5 %".
# Because of the NER span priority there seems to be no way we can overwrite this.
# There we shall check both result formats.
(rule $PercentPhrase ($PHRASE) (FilterNerSpanFn PERCENT))

(rule $CountPercent ($Number) (IdentityFn))
(rule $CountPercent ($PercentPhrase) (IdentityFn))
(rule $CountPercent ($Number $PercentToken) (ConcatFn ""))

# Phrase with length constraint
(rule $PhraseValue ($PHRASE) (FilterPosTagFn span reverse IN TO DT WDT))

# Passive Objects
# (def @passive_object (string "(object)"))
# (rule $PassiveObject ($TOKEN) (FilterPosTagFn token DT WDT PRP PRP$))



# Grouping
(def @group (string "group"))
(rule $GroupToken ($TOKEN) (FilterTokenFn lemma group))
(rule $GroupBy ($GroupToken ($Prep optional)) (ConstantFn @group))
(rule $GroupBy (by) (ConstantFn @group))

# Nodes
(def @node (string "node"))
(rule $Node (node) (ConstantFn @node))

# Utils
(rule $NumberToString ($Number) (lambda x (call .toString (var x))))
